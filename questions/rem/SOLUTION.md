# 正则表达式匹配

## 解题思路
当我第一次看到这个问题时，我想到使用动态规划来解决，原因如下：
1. 需要匹配整个字符串，而不是仅仅查找子串
2. '*' 操作符可以匹配零个或多个字符，这会产生多种可能性
3. 需要考虑字符串和模式不同部分之间的关系
4. 问题具有重叠子问题和最优子结构特性

## 解决方案
我实现了一个动态规划解决方案，主要步骤如下：

1. **状态定义**：
   - 使用二维数组 `dp[i][j]` 表示字符串 `s` 的前 `i` 个字符和模式 `p` 的前 `j` 个字符是否匹配
   - 最终答案存储在 `dp[m][n]` 中，其中 `m` 和 `n` 分别是字符串和模式的长度

2. **初始化**：
   - 设置 `dp[0][0] = true`，表示空字符串匹配空模式
   - 处理以 '*' 开头的模式（如 "a*", "a*b*"）：`dp[0][j] = dp[0][j-2]`

3. **状态转移**：
   - 对于匹配的字符或 '.'：`dp[i][j] = dp[i-1][j-1]`
   - 对于 '*'：
     - 情况1：匹配零个字符：`dp[i][j] = dp[i][j-2]`
     - 情况2：匹配一个或多个字符：`dp[i][j] = dp[i][j] || dp[i-1][j]`

4. **优化**：
   - 使用两个一维数组替代二维数组，减少空间复杂度
   - 实现提前终止，当没有匹配可能时直接返回 false

## 复杂度分析
- 时间复杂度：$$O(m*n)$$
  - 需要填充大小为 m*n 的表格
  - 每个单元格的计算时间为常数
  - 其中 m 和 n 分别是字符串和模式的长度

- 空间复杂度：$$O(n)$$
  - 优化后只需要两个长度为 n+1 的一维数组
  - 其中 n 是模式的长度


## 结论
动态规划方法提供了一个高效的解决方案。通过将问题分解为更小的子问题并利用最优子结构，我们可以在多项式时间内解决它。空间优化和提前终止技术进一步提高了解决方案的性能。 