# 寻找两个有序数组的中位数

## 我的解题思路
看到这个题目的时候，我首先想到的是中位数的定义：在一个有序数组里，中位数就是那个把数组分成两半的数，左边都小于等于它，右边都大于等于它。

然后我注意到题目要求时间复杂度是 O(log(m+n))，这让我想到要用二分查找。因为：
1. 二分查找的时间复杂度正好是 O(log n)
2. 两个数组都是有序的，这给了我们利用二分查找的机会
3. 我们不需要真的合并数组，只需要找到中位数的位置就行

## 我是怎么做的
我实现了一个基于二分查找的解决方案，主要思路是：

1. **问题转化**：
   - 把找中位数的问题变成找第 k 小的数
   - 如果总长度是奇数，k = (m+n+1)/2
   - 如果总长度是偶数，需要找第 k 和 k+1 小的数

2. **二分查找策略**：
   - 每次比较两个数组的第 k/2 个元素
   - 谁小就排除谁的前 k/2 个元素
   - 更新 k 值，继续在剩下的部分找

3. **处理边界情况**：
   - 数组为空怎么办
   - k=1 的时候怎么处理
   - 数组长度不够 k/2 怎么办

4. **优化技巧**：
   - 让第一个数组总是短的，减少比较次数
   - 用递归写代码更简洁
   - 提前处理特殊情况，提高效率

## 复杂度分析
- 时间复杂度：$$O(log(min(m,n)))$$
  - 每次都能排除一半的元素
  - 只在短的数组上做二分查找
  - m 和 n 是两个数组的长度

- 空间复杂度：$$O(1)$$
  - 只用几个变量存中间结果
  - 递归深度是 O(log(min(m,n)))，但可以改成循环

## 关键点
1. 把中位数问题变成找第 k 小的问题，这个转化很关键
2. 利用有序数组的性质，每次都能排除一半的元素
3. 边界情况要处理清楚，特别是空数组的情况
4. 确保算法满足时间复杂度要求，这是题目的硬性要求

## 我的总结
这个基于二分查找的解决方案不仅满足了时间复杂度要求，而且实现起来也不难。通过把问题转化成找第 k 小的数，我们可以利用有序数组的性质，每次都能快速排除一半的元素。这个算法在处理大数据的时候特别有效，因为它的时间复杂度是对数级的。 